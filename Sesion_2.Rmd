---
title: "Capacitaci√≥n en R y herramientas de productividad"
subtitle: "Sesi√≥n 2"  
author: 
date: '`r Sys.Date()`'
output:
  xaringan::moon_reader:
    seal: false
    #lib_dir: libs
    css: xaringan-themer.css
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: False

---


class: center, middle

.linea-superior[]
.linea-inferior[]


<img src="imagenes/logo_portada2.png" width="200" />

## Capacitaci√≥n en R y herramientas de productividad

## Proyecto Estrat√©gico Servicios Compartidos para la Producci√≥n Estad√≠stica

## Procesamiento de bases de datos

### Agosto 2020

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(message = FALSE) 
```

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Contenidos de hoy

El objetivo de esta sesi√≥n es aprender a manipular *data frames*.

Para cumplir con el objetivo, revisaremos los siguientes temas:

--

- Un breve resumen de lo visto en la sesi√≥n anterior.

--

- Importaci√≥n de datos a R (.csv, .xlsx, .dta, .sav, .RData).

--

- Funciones del paquete `dplyr` para la manipulaci√≥n de *data frames*.

--

- Encadenamiento de instrucciones: uso de *pipes*.

--

- Agregaci√≥n de unidades (`group_by`).

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Breve resumen

Antes de avanzar, una recopilaci√≥n de los puntos vistos en la primera sesi√≥n y que ser√°n necesarios en esta sesi√≥n

--

- **¬øQu√© es un script?**

Corresponde a un documento de texto en el cual se escribe una serie de instrucciones para R.

--

- **¬øQu√© es un paquete?**

Corresponde a una colecci√≥n de `funciones` dise√±adas para atender distintas tareas. Los paquetes complementan a las funciones de base existentes en R. Para poder ejecutar estas funciones, es necesario instalar el `paquete` y cargar las `librer√≠as`.

--

- **¬øQu√© se puede entender por funci√≥n?**

Corresponde a un conjunto de instrucciones que permite automatizar rutinas largas y/o complicadas.

--

```{r , warning=FALSE}
round(x = c(4.5, 4.4444449), digits = 1)
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Breve resumen

- **¬øC√≥mo se asigna un valor a un elemento?**

--

```{r , warning=FALSE}
# Utilizando la expresi√≥n "<-" se asigna un valor.
z <- 1
# El objeto con el valor asignado se puede usar en funciones.
zz <- z + 3
# print() se utiliza para mostrar el valor del objeto en la consola.
print(zz)
```

--

- **¬øQu√© es un vector?**:

Es el objeto m√°s b√°sico en R. Este objeto es una forma de almacenar datos.


```{r, warning=FALSE}
x <- c(1, 2, 5)
print(x)
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Breve resumen

- **Tipos de vectores**

```{r, warning=FALSE, eval=FALSE}
character = c("gato", "perro")
numeric   = c(8, 15.9, -2.1)  # n√∫meros reales
integer   = c(2L, 4L) # L indica que son enteros
logical   = c(TRUE, FALSE, TRUE)
complex   = 3 + 4i
```

--

Los vectores son at√≥micos. <b>¬øQu√© significa esto?</b>

--

```{r, warning=FALSE}
v <-  c("gato", 1)
class(v)
v <-  c(1L, 2.2)
class(v)
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Breve resumen

- **Operadores matem√°ticos**

```{r, warning=FALSE, eval=FALSE}
x + y   # suma
x - y   # resta
x * y   # multiplicaci√≥n
x / y   # divisi√≥n
x ^ y   # exponenciaci√≥n
x %% y  # m√≥dulo
x %/% y # cociente
```

--

Al realizar una operaci√≥n matem√°tica sobre dos vectores, la operaci√≥n se realiza entre los componentes que ocupan la misma `posici√≥n` en ambos vectores.

```{r, warning=FALSE}
x <- c(0, 1, 2)
y <- c(0, -2, 1)
x + y
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Breve resumen

- **Operadores relacionales**

```{r, warning=FALSE, eval=FALSE}
x < y     # x menor que y
x > y     # x mayor que y
x <= y    # x menor o igual que y
x >= y    # x mayor o igual que y
x == y    # x igual a y
x != y    # x distinto a y
```

--

Al realizar una operaci√≥n relacional entre dos vectores, la **relaci√≥n** se realiza entre los componentes que ocupan la misma `posici√≥n` en ambos vectores.

--

El resultado de una operaci√≥n relacional es **TRUE** o **FALSE** en cada componente del nuevo vector.

```{r, warning=FALSE}
x <- c(0, 1, 2)
y <- c(0, -2, 1)
x == y
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Breve resumen

- **Operadores l√≥gicos (booleanos)**

```{r, warning=FALSE, eval=FALSE}
x | z     # x o z es verdadero
x & z     # x y z son verdaderos
!x        # x no es verdadero (negaci√≥n)
isTRUE(x) # x es verdadero (afirmaci√≥n)
```

--

Las operaciones l√≥gicas analizan el valor de verdad de dos sentencias.

--

```{r, warning=FALSE}
(24 > 5) & (-1 * -1 > 0)
length(c(1:10)) == length(seq(from = 1, to = 10, by = 2))
```

--

- **Indexaci√≥n**

```{r, warning=FALSE}
c("a", "a,b", "c")[3] # El tercer elemento
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Breve resumen

- **¬øQu√© es un data frame?**

Es una estructura de datos de dos dimensiones (rectangular) que puede contener datos de diferentes tipos, por lo tanto, es heterog√©nea. Esta estructura de datos es la m√°s usada para realizar an√°lisis de datos, y es la estructura con la cual trabajaremos en esta secci√≥n.

--

- **Operador $**

Se utiliza para vincular una variable con un objeto.

--

- **Funci√≥n table()**

Se utiliza para tabular un resultado.

--

```{r, warning=FALSE}
x <- data.frame(nombres = c("Ignacio", "Klaus", "Juan", "Ignacio"))
# Tabulaci√≥n
table(x$nombres)
```

---

background-image: url("imagenes/import.jpg")
background-size: cover
class: center, bottom, inverse

# Importaci√≥n de datos

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Importaci√≥n de datos

<b>R</b> tiene distintos paquetes para importar datos, diferenciando la extensi√≥n de los archivos.

--

- Para importar archivos delimitados (.csv, .txt, .tab), existe el paquete `readr`. Dentro de las funciones de ese paquete, la funci√≥n `read_csv()` permite la importaci√≥n de archivos con la extensi√≥n "**.csv**".

```{r, warning=FALSE, eval=FALSE}
# Para usar el paquete primero es necesario cargarlo
library(readr)
# Al usar la funci√≥n, asignamos el archivo a un valor
base_csv  <-  read_csv(file = "ejemplo.csv")
```

--

- El paquete `readxl` nos permite importar archivos de Excel. Una de sus funciones es `read_excel()`.

```{r, warning=FALSE, eval=FALSE}
# Para usar el paquete primero es necesario cargarlo
library(readxl)
# Al usar la funci√≥n, asignamos el archivo a un valor
base_excel  <-  read_excel(path = "ejemplo_excel.xlsx",
                           sheet="Hoja1")
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Importaci√≥n de datos

Tanto las funciones de `readr` como `readxl` tienen argumentos que permiten setear distintas opciones para la importaci√≥n.

--

<br>

.pull-left[
### `readr`

- Cambiar nombres de columnas

- Saltarse l√≠neas al momento de importar

- Recodificar valores perdidos
]

.pull-right[
### `readxl`

- Leer un rango espec√≠fico de la hoja de c√°lculo

- Cambiar nombres de columnas

- Saltarse l√≠neas al momento de importar

- Recodificar valores perdidos
]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Importaci√≥n de datos

.pull-left[
Para importar archivos guardados desde Stata o SPSS existe el paquete `haven`.

Al igual que los paquetes `readxl` o `readr` tiene funciones bastante expl√≠citas respecto de lo que hacen:

- **SPSS**: `read_sav()` permite importar archivos ".sav".

- **Stata**: `read_dta()` permite importar archivos ".dta".
]

.pull-right[
.center[
![](imagenes/logo_haven.png)
]
]

```{r, warning=FALSE, eval=FALSE}
# Cargar librer√≠a
library(haven)
esi <-  read_dta("data/esi_2018_personas.dta")
```

--

La funci√≥n `read_dta()` permite cargar bases de datos desde sitios web.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Importaci√≥n de datos

Los archivos de R tienen la extensi√≥n `.RData`.

--

Para importar estas bases se usa el comando `load()`.

--

La importaci√≥n de un archivo en R no requiere una asignaci√≥n de valor.

--

Estos archivos puede incluir m√°s de un objeto.

--

```{r, warning=FALSE}
load(file = "data/Censo_area.RData")
```

--

Comencemos con nuestro ejercicio...

--

Importemos el archivo de Excel "**`Censo_area.xlsx`**"... 

--

**¬øQu√© funci√≥n debemos utilizar?**

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Importaci√≥n de datos

Debemos utilizar la funci√≥n `read_excel` de la librer√≠a `readxl`.

--

Esta funci√≥n requiere indicar el nombre de la base a importar, as√≠ como la ruta en donde se encuentra guardada.

--

**IMPORTANTE**: al escribir la ruta, se debe utilizar el s√≠mbolo "**`/`**".

--

```{r, warning=FALSE}
library(readxl)
base <- read_excel(path = "data/Censo_area.xlsx")
```

--

¬øC√≥mo se puede revisar la estructura de la base de datos?

--

```{r, warning=FALSE}
str(base)
```

--

Ahora que importamos la base de datos, trabajaremos con la manipulaci√≥n de los data frames.

---

background-image: url("imagenes/transformer.gif")
background-size: cover
class: center, bottom, inverse

# Transformaci√≥n de datos

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## El paquete `dplyr`


.pull-left[

Para la manipulaci√≥n de los data frames existe un paquete llamado **`dplyr`**.

Este paquete fue desarrollado por Hadley Wickham de RStudio.

Es una versi√≥n optimizada de un paquete anterior llamado `plyr`.
 
El paquete `dplyr` proporciona una "gram√°tica" (particularmente verbos) para la manipulaci√≥n y operaciones con data frames.
 
Los paquetes `dplyr`, `readr`, `readxl` y `haven` forman parte del universo de [`tidyverse`](https://www.tidyverse.org).

]

.pull-right[
.center[
![](https://d33wubrfki0l68.cloudfront.net/071952491ec4a6a532a3f70ecfa2507af4d341f9/c167c/images/hex-dplyr.png)
]
]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

Durante esta sesi√≥n veremos siete funciones del paquete **`dplyr`** que se utilizan para la manipulaci√≥n de data frames.

--

- **select**: selecciona y devuelve un conjunto de columnas.

--

- **filter**: selecciona y devuelve un conjunto de filas seg√∫n una o varias condiciones l√≥gicas.

--

- **arrange**: reordena filas de un data frame.

--

- **rename**: renombra variables en un data frame.

--

- **mutate**: a√±ade nuevas variables o transforma variables existentes.

--

- **group_by**: agrupa filas de un data frame.

--

- **summarise**: genera res√∫menes de datos.

--

Estas funciones ser√°n algunas de nuestras mejores compa√±eras y siempre nos acompa√±ar√°n en nuestro camino de programaci√≥n.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

Todas estas funciones tienen en com√∫n una serie de argumentos:

--

- El primer argumento es el data frame a manipular.

--

- Los otros argumentos describen qu√© hacer con el data frame especificado en el primer argumento.

--

-	El valor de retorno de la funci√≥n es un nuevo data frame.

--

Como veremos en esta sesi√≥n, una de las principales ventajas de estas funciones es que podemos referirnos a las columnas en el data frame directamente sin utilizar el operador ‚Äú**`$`**‚Äù, es decir, solo con el nombre de la variable.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `select()`

La primera funci√≥n que veremos es la funci√≥n `select()`.

--

Esta funci√≥n es utilizada para seleccionar columnas dentro de un data frame.

--

El resultado de esta funci√≥n corresponde a un data frame que solo incluye las variables seleccionadas.

--

.center[
<img src="imagenes/select.png" width="300" />
]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `select()`

El orden definido en la selecci√≥n de variables, es el orden que tendr√°n las columnas en el resultado.

--

La selecci√≥n puede ser realizada...

--

.pull-left[
...seg√∫n nombre de la variable.

```{r, warning=FALSE}
library(dplyr)
head(select(base, EDAD, N))
```
]

--

.pull-right[
...seg√∫n √≠ndice de la variable.

```{r, warning=FALSE}
library(dplyr)
head(select(base, 3, 2))
```
]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `select()`

Otra forma de seleccionar consiste en definir qu√© columnas no se seleccionar√°n. Para esto es necesario incluir el signo menos ("**`-`**") antes de las columnas a seleccionar

--

Esta manera de seleccionar se puede entender como "la eliminaci√≥n de columnas".

--

Realicemos un ejercicio...

--

En un objeto llamado `ejemplo`, seleccionar solo las primeras 3 columnas del objeto `base`.

--

```{r, warning=FALSE}
head(select(base, -4, -5), n = 4)
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `select()`

Realicemos algunos ejercicios...

--

Creemos un data frame:

```{r, warning=FALSE}
df <- data.frame(x1 = c(1:3),
                 x2 = c(1,7,2),
                 y3 = c("a","b","c"),
                 x4 = c(5,-1,8),
                 x5 = c("perro","gato","conejo"),
                 y1 = c(1, "perro", "gato"))
```

--

Ahora que creamos el data frame, realicemos algunas selecciones:

--

- Seleccionemos todas las columnas excepto x4 y x5.

--

- Reordenemos las columnas en el siguiente orden: x1, y1, x5, y3, x2 y x4.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `select()`

Cuando trabajamos con bases de datos, a veces nos encontramos con variables cuyo nombre sigue cierto patr√≥n, por ejemplo:

- La primera letra es la misma (a1, a2, a3).

- La variable posee un mismo sufijo (a1_otro, a2_otro, a3_otro)

--

Existen funciones auxiliares a `select()`, las cuales permiten trabajar con ciertos patrones.

--

Una que utilizaremos reiteradas veces dentro de las siguientes secciones es `starts_with()`. 
--
Esta funci√≥n auxiliar se utiliza para identificar las variables que comienzan con un cierto prefijo.

--

Por ejemplo, seleccionemos las variables que comienzan con la letra "**x**".

--

```{r, warning=FALSE}
head(select(df, starts_with("x")))
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `filter()`

--

Esta funci√≥n se utiliza para filtrar un data frame seg√∫n alguna condici√≥n a definir.

--

As√≠ como la funci√≥n `select` es utilizada para seleccionar columnas de un data frame, la funci√≥n `filter` puede ser entendida como la selecci√≥n de filas de un data frame.

--

.center[
<img src="imagenes/filter.png" width="400" />
]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `filter()`

¬øEs posible filtrar en base a m√°s de una condici√≥n?

--

**SI**, es posible utilizando operadores l√≥gicos.

--

Por ejemplo, si queremos filtrar nuestra base, y seleccionar a las mujeres de la regi√≥n 6 y de edad 35, debemos hacer lo siguiente...

--

```{r, warning=FALSE}
library(dplyr)
filter(base, SEXO == 2 & C√ìDIGO_REGI√ìN == 6 & EDAD == 35)
```

--

**Ejercicio**: filtrar el data frame "df", seg√∫n los criterios: x1 > 2 y x5 es distinto de "perro".

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `arrange()`

--

Como se vio en la sesi√≥n anterior, esta funci√≥n se utiliza para reordenar las filas de un data frame:

--

- El orden se puede realizar seg√∫n una o m√°s columnas.

--

- El reordenamiento se realiza seg√∫n el orden de las columnas seleccionadas.

--

- Por defecto, el orden es ascendente.

--

- Para ordenar de manera descendente se debe utilizar la funci√≥n auxiliar `desc()`.

```{r, warning=FALSE}
head(arrange(base,desc(SEXO),N),n=3)
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `rename()`

--

Si queremos **`renombrar`** una variable (columna) de un data frame, existen m√∫ltiples formas y varias muy complejas.

--

La funci√≥n `rename` permite modificar el nombre de una variable de una manera sencilla, sin editar el resto de variables.

--

Para obtener el nombre de las variables en un data frame se utiliza la funci√≥n `names()`.

--

```{r, warning=FALSE}
# Funci√≥n para obtener nombres de las columnas
names(df)
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `rename()`

La funci√≥n **`rename`** permite renombrar una variable o m√°s de un variable cada vez.

--

```{r, warning=FALSE}
df <- rename(df, var1 = x1, var5 = x5)
head(df)
```

--

La funci√≥n **`rename_all`** permite renombrar todas las variables dentro de un data frame, y combinado con la funci√≥n `tolower` permite pasar a min√∫scula todos los nombres.

```{r, warning=FALSE}
base <- rename_all(base, tolower)
names(base)
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `mutate()`

La funci√≥n **`mutate()`** tiene la finalidad de realizar transformaciones sobre los valores de un data frame.

--

Algunas de las transformaciones posibles son:

--

- Cambiar el formato de una variable.

--

```{r, warning=FALSE}
# Cambiar el formato de una variable
class(df$x4)
df <- mutate(df, x4 = as.character(x4))
class(df$x4)
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `mutate()`

- Modificar el valor de alguna variable.

En este caso se requiere la utilizaci√≥n de una funci√≥n auxiliar llamada `ifelse()`. Esta funci√≥n trabaja con los siguientes argumentos: *test*, *yes* y *no*.

--

```{r, warning=FALSE}
# Modificar la edad "100 o m√°s" por 100
base <- mutate(base,
               edad = ifelse(test = edad == "100 o m√°s",
                             yes = "100",
                             no = edad))
table(base$edad == "100")
```


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `mutate()`

- Permite utilizar variables del data frame para transformar otras.

--

Un mini ejercicio:
--
 utilizando el objeto **`base`**, generar una variable llamada `tramos_edad`, la cual agrupe a las personas en 3 tramos (0-30, 31-60, 61-100).
 
--

```{r, warning=FALSE}
# Cambiar el formato de una variable
base <- mutate(base,
               edad = as.numeric(edad))
base <- mutate(base,
               tramos_edad = ifelse((edad %in% 0:30),
                                    1,
                                    ifelse((edad %in% 31:60),
                                           2,
                                           3)))
table(base$tramos_edad, useNA = "always")
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `mutate()`

- Permite modificar el valor de m√°s de una variable. La modificaci√≥n se realiza de izquierda a derecha.

--

- Permite crear una variable que no existe

--

A continuaci√≥n un peque√±o ejercicio...

--

Utilizando el data frame `df`, generar una variable `x1` con los mismos valores de `var1`. Luego, generar una variable `x6` cuyos valores sean igual a `x1 + x2`. Asignar el resultado de la funci√≥n al data frame `df`.

--

```{r, warning=FALSE}
df <- mutate(df,
            x1 = var1,
            x6 = x1 + x2)
head(df)
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

Hasta ahora hemos visto c√≥mo `renombrar` variables, c√≥mo `seleccionar` columnas, c√≥mo `filtrar` filas, c√≥mo `reordenar` las filas y c√≥mo `crear/transformar` variables en un data frame.

--

Realicemos un ejercicio aplicando lo aprendido:

- Utilizando el data frame `base`, renombrar la variable `c√≥digo_regi√≥n` y asignarle el nombre `region`. El resultado guardarlo en el objeto `resultado`.

Las siguientes transformaciones realizarlas sobre el objeto `resultado`.

- Reordenar las columnas de forma tal que la columna `n` corresponda a la √∫ltima columna del data frame.

- Cambiar el formato de las variables `region` y `edad`, y convertirlas en variables num√©ricas (usar `as.numeric()`).

- Filtrar el objetivo, y solo quedar con los registros que correspondan a mujeres (sexo == 2) con regi√≥n distinta a la 1 (region == 6).

- Reordenar las filas de acuerdo a: `region` y `edad`.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

El resultado es el siguiente:

```{r, warning=FALSE}
# Renombrar
resultado <- rename(base, region = c√≥digo_regi√≥n)
# Seleccionar
resultado <- select(resultado, c(1,2,4,5,3))
# Cambiar el formato
resultado <- mutate(resultado, region = as.numeric(region),
                    edad = as.numeric(edad))
# Cambiar el formato
resultado <- filter(resultado, (sexo == 2 & region == 6))
# Reordenar filas
resultado <- arrange(resultado, region, edad)
# Miremos el resultado
head(resultado, n = 3)
```

--

¬øEs posible encadenar todas estas instrucciones?
--
 Si, utilizando el operador **`%>%`** (llamado **pipe**)

---

background-image: url("imagenes/pipes.jpg")
background-size: cover
class: center, bottom, inverse

# <b><font color = "Black">Uso de pipes</font></b>

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Uso de pipes

El operador **%>%** nos permite tomar el resultado de una funci√≥n y mandarlo directamente a la siguiente funci√≥n, concatenando acciones.

--

Se puede leer como "luego" o "a continuaci√≥n".

--

Este operador nos ayudar√° enormemente a mejorar la legibilidad de un c√≥digo.

--

Utilizando pipes, el resultado del ejercicio anterior es posible escribirlo de la siguiente manera:

```{r, warning=FALSE, eval=FALSE, eval=FALSE}
library(dplyr)
resultado <- base %>% # data frame a manipular
  rename(region = c√≥digo_regi√≥n) %>% # renombrar
  select(1,2,4,5,3) %>% # seleccionar columnas
  mutate(region = as.numeric(region),
         edad = as.numeric(edad)) %>% # cambiar formatos
  filter(sexo == 2 & region == 6) %>% # filtrar data frame
  arrange(region, edad) # ordenar filas
```

---

background-image: url("imagenes/group_by_ungroup.png")
background-size: 100% 100%
class: center, bottom, inverse

# <font color = "blue">Agrupaci√≥n de unidades</font>

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Resumen de informaci√≥n

Para la generaci√≥n de tablas de resumen de informaci√≥n se utilizan dos funciones: 

- `group_by()`
- `summarise()`

--

La funci√≥n `group_by()` permite agrupar a las observaciones seg√∫n una categor√≠a de una variable y aplicarles alguna funci√≥n.

--

Esto resulta muy √∫til pues muchos nuestros an√°lisis estad√≠sticos se aplican sobre grupos definidos por una variable o una combinaci√≥n de variables (sexo, regi√≥n, comuna, etc).
 
--

Gran parte del an√°lisis de datos que realizamos involucra la aplicaci√≥n de una estrategia que en ingl√©s se acu√±a como *split-apply-combine*.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Resumen de informaci√≥n

.center[
<img src="imagenes/group.png" width="400" />
]

- Primero `group_by()` divide el *data frame*.

- Luego opera una funci√≥n con la data fragmentada.

- Finalmente `group_by()` vuelve a combinar los resultados.

--

¬øQu√© funciones podemos aplicar sobre la data fragmentada?

--

Todas las funciones que hemos visto durante esta sesi√≥n pueden ser combinadas con `group_by()`, pero una que funciona perfectamente es `summarise()`.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Resumen de informaci√≥n

La funci√≥n `summarise()` crea una o m√°s escalares resumiendo informaci√≥n de variables existentes en un data frame.

--

En combinaci√≥n con otras funciones, es una manera de tabular informaci√≥n.

--

Algunas funciones que se pueden operar dentro de `summarise()` son:

--

- Tendencia central: `mean()`, `median()`.

--

- Rango: `min()`, `max()`. `quantile()`.

--

- Posici√≥n: `first()`, `last()`.

--

- Conteo: `n()`, `n_distinct()`.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Resumen de informaci√≥n

Ahora que ya conocemos estas funciones: ¬øcu√°ntas hombres hay por tipo de √°rea y regi√≥n?

--

Para resolver a la pregunta, tomamos el objeto **resultado**, filtramos a los hombres, agrupamos por tipo de √°rea y regi√≥n, y obtenemos la suma de "n".

--

```{r, warning=FALSE}
base %>%
  rename(region = c√≥digo_regi√≥n) %>%
  filter(sexo == 1 & region == 12) %>%
  group_by(area, tramos_edad) %>%
  summarise(total = sum(n)) %>%
  ungroup()
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Resumen de informaci√≥n

Revisemos el ejercicio bonus de la tarea 1: ¬øcu√°l es el nombre m√°s usado en Chile en todos los tiempos?

--

Lo primero que tenemos que hacer es cargar la librer√≠a **guaguas**, luego asignar la base de guaguas a un objeto llamado guaguas, por √∫ltimo, debemos generar el cuadro resumen.

--

```{r, warning=FALSE}
library(guaguas)
guaguas <- guaguas
guaguas %>%
  group_by(nombre) %>%
  summarise(total = sum(n)) %>%
  arrange(desc(total)) %>%
  slice(1) %>%
  select(nombre)
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ejercicio para la üè†

--

Vamos a trabajar con una base real de la **Encuesta Nacional Urbana de Seguridad Ciudadana (ENUSC)**, que levanta el INE a√±o a a√±o. Utilizaremos la √∫ltima versi√≥n publicada (2019). 

--

Para la ENUSC, un **hogar victimizado** es aquel en el cual durante el √∫ltimo a√±o **alguno de sus miembros fue v√≠ctima de al menos uno de los siguientes delitos:** 

--

- robo con intimidaci√≥n (**A1_1_1**)
- robo por sorpresa (**B1_1_1**)
- robo con fuerza en la vivienda (**C1_1_1**)
- hurto (**D1_1_1**)
- lesiones (**E1_1_1**)
- robo de veh√≠culo (**G1_1_1**)
- robo desde veh√≠culo (**H1_1_1**)

--

Es decir, basta con tener un valor 1 (s√≠) en cualquiera de estas variables para que este hogar sea **victimizado (VA_DC == 1)**.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ejercicio para la üè†

## Ahora s√≠ el ejercicio:

En primer lugar debes descargar la base de datos 2019 desde el [sitio de la ENUSC en la p√°gina del INE](https://www.ine.cl/estadisticas/sociales/seguridad-publica-y-justicia/seguridad-ciudadana). Puedes descargarla en formato .csv o en .sav (SPSS). Crea o escoge un fichero en tu computador y descomprimer el archivo ah√≠. Si deseas, renombra la base de datos para facilitar el trabajo con ella.

--

1- Utilizando las funciones de **importaci√≥n** aprendidas, carga la base de datos en tu entorno de trabajo de **R**.

--

2- ¬øCu√°ntas observaciones y cuantas variables tiene la base?

--

3- La base es un poco **grande** y los nombres de las variables **poco intuitivos** üòµ. Simplifiquemos la base:

--

    - filtrando solo a los informantes de la encuesta (Kish == 1).
    
    - seleccionando solo las variables que que usaremos (`enc_region`, `VA_DC` y   
    las variables de victimizaci√≥n indicadas en la l√°mina anterior)
    
    - y renombrando estas variables para hacerlas m√°s entendibles (sugerencia: region,
    intimidacion, sorpresa, fuerza_viv, hurto, lesiones, de_vehiculo, desde_vehiculo) 
    
---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ejercicio para la üè†

--
    
  Puedes hacer todo lo anterior en una sola instrucci√≥n usando `pipes` (`%>%`). Te recomendamos guardarla en un objeto diferente, por ejemplo: `enusc_2`.
  
--

 4- ¬øCu√°ntas observaciones y cuantas variables tiene tu base ahora?

--

 5- Ahora, Genera una **variable dicot√≥mica con valores 0 y 1** que indique, a partir de las variables de delitos, si un hogar ha sido v√≠ctima de al menos un delito. Crearla dentro de la base de datos y ponerle como nombre `VA_DC_2`.

--

 6- Compara la victimizaci√≥n agregada que calculamos (`VA_DC_2`) con la que ya viene construida en la base original (`VA_DC`). ¬øSon iguales?

--

 7- Crear una tabla que muestre la victimizaci√≥n agregada para cada regi√≥n (**Sin usar factores de expansi√≥n**).


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ejercicio para la üè†

**hint 1** üëÄ:

Puedes usar `ifelse()`, a trav√©s de mutate, para generar variables dicot√≥micas.

```{r, eval = F}
enusc_2 <- enusc_2 %>% 
  mutate(intimidacion = ifelse(intimidacion==1,1,0))
```

--

**hint 2** üïµ:

Existe una funci√≥n llamada `rowSums()`. que te podr√≠a servir para sumar un total fila sobre un set de variables.

--

**hint 3** ü•∏:

Los valores `NA` son muy contagiosos. Puedes evitar su influencia usando el argumento `na.rm = TRUE`.


.center[ü§îüß†]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Referencias

Nada de esto ser√≠a posible sin:

- [`R fot Data Science, de Hadley Wickham`](https://r4ds.had.co.nz/)

- [`Advanced R, de Hadley Wickham`](http://adv-r.had.co.nz/Introduction.html)

- [`Data wrangling, exploration, and analysis with R, de Jenny Bryan`](https://stat545.com/index.html)

- [`Introduction to R, de Data Carpentry`](https://datacarpentry.org/R-genomics/01-intro-to-R.html#functions)

- [`Xaringan: Presentation Ninja, de Yihui Xie`](https://github.com/yihui/xaringan). Para generar esta presentaci√≥n con la planilla ninja ‚öî

R for Data Science tiene una traducci√≥n al espa√±ol realizada por la comunidad hispana de R:

- [`R para ciencia de datos, de Hadley Wickham`](https://es.r4ds.hadley.nz/)

---

class: center, middle

.linea-superior[]
.linea-inferior[]


<img src="imagenes/logo_portada2.png" width="200" />

## Capacitaci√≥n en R y herramientas de productividad

## Proyecto Estrat√©gico Servicios Compartidos para la Producci√≥n Estad√≠stica

## Procesamiento de bases de datos

### Agosto 2020