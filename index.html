<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Capacitaci√≥n en R y herramientas de productividad</title>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <meta name="date" content="2020-08-25" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">



class: center, middle

.linea-superior[]
.linea-inferior[]


&lt;img src="imagenes/logo_portada2.png" width="200" /&gt;

## Capacitaci√≥n en R y herramientas de productividad

## Proyecto Estrat√©gico Servicios Compartidos para la Producci√≥n Estad√≠stica

## Procesamiento de bases de datos

### Agosto 2020





---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Contenidos de hoy

El objetivo de esta sesi√≥n es aprender a manipular *data frames*.

Para cumplir con el objetivo, revisaremos los siguientes temas:

--

- Un breve resumen de lo visto en la sesi√≥n anterior.

--

- Importaci√≥n de datos a R (.csv, .xlsx, .dta, .sav, .RData).

--

- Funciones del paquete `dplyr` para la manipulaci√≥n de *data frames*.

--

- Encadenamiento de instrucciones: uso de *pipes*.

--

- Agregaci√≥n de unidades (`grupo_by`).

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Breve resumen

Antes de avanzar, una recopilaci√≥n de los puntos vistos en la primera sesi√≥n y que ser√°n necesarios en esta sesi√≥n

--

- **¬øQu√© es un script?**

Corresponde a un documento de texto en el cual se escribe una serie de instrucciones para R.

--

- **¬øQu√© es un paquete?**

Corresponde a una colecci√≥n de `funciones` dise√±adas para atender distintas tareas. Los paquetes complementan a las funciones de base existentes en R. Para poder ejecutar estas funciones, es necesario instalar el `paquete` y cargar las `librer√≠as`.

--

- **¬øQu√© se puede entender por funci√≥n?**

Corresponde a un conjunto de instrucciones que permite automatizar rutinas largas y/o complicadas.

--


```r
round(x = c(4.5, 4.4444449), digits = 1)
```

```
## [1] 4.5 4.4
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Breve resumen

- **¬øC√≥mo se asigna un valor a un elemento?**

--


```r
# Utilizando la expresi√≥n "&lt;-" se asigna un valor.
z &lt;- 1
# El objeto con el valor asignado se puede usar en funciones.
zz &lt;- z + 3
# print() se utiliza para mostrar el valor del objeto en la consola.
print(zz)
```

```
## [1] 4
```

--

- **¬øQu√© es un vector?**:

Es el objeto m√°s b√°sico en R. Este objeto es una forma de almacenar datos.



```r
x &lt;- c(1, 2, 5)
print(x)
```

```
## [1] 1 2 5
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Breve resumen

- **Tipos de vectores**


```r
character = c("gato", "perro")
numeric   = c(8, 15.9, -2.1)  # n√∫meros reales
integer   = c(2L, 4L) # L indica que son enteros
logical   = c(TRUE, FALSE, TRUE)
complex   = 3 + 4i
```

--

Los vectores son at√≥micos. &lt;b&gt;¬øQu√© significa esto?&lt;/b&gt;

--


```r
v &lt;-  c("gato", 1)
class(v)
```

```
## [1] "character"
```

```r
v &lt;-  c(1L, 2.2)
class(v)
```

```
## [1] "numeric"
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Breve resumen

- **Operadores matem√°ticos**


```r
x + y   # suma
x - y   # resta
x * y   # multiplicaci√≥n
x / y   # divisi√≥n
x ^ y   # exponenciaci√≥n
x %% y  # m√≥dulo
x %/% y # cociente
```

--

Al realizar una operaci√≥n matem√°tica sobre dos vectores, la operaci√≥n se realiza entre los componentes que ocupan la misma `posici√≥n` en ambos vectores.


```r
x &lt;- c(0, 1, 2)
y &lt;- c(0, -2, 1)
x + y
```

```
## [1]  0 -1  3
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Breve resumen

- **Operadores relacionales**


```r
x &lt; y     # x menor que y
x &gt; y     # x mayor que y
x &lt;= y    # x menor o igual que y
x &gt;= y    # x mayor o igual que y
x == y    # x igual a y
x != y    # x distinto a y
```

--

Al realizar una operaci√≥n relacional entre dos vectores, la **relaci√≥n** se realiza entre los componentes que ocupan la misma `posici√≥n` en ambos vectores.

--

El resultado de una operaci√≥n relacional es **TRUE** o **FALSE** en cada componente del nuevo vector.


```r
x &lt;- c(0, 1, 2)
y &lt;- c(0, -2, 1)
x == y
```

```
## [1]  TRUE FALSE FALSE
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Breve resumen

- **Operadores l√≥gicos (booleanos)**


```r
x | z     # x o z es verdadero
x &amp; z     # x y z son verdaderos
!x        # x no es verdadero (negaci√≥n)
isTRUE(x) # x es verdadero (afirmaci√≥n)
```

--

Las operaciones l√≥gicas analizan el valor de verdad de dos sentencias.

--


```r
(24 &gt; 5) &amp; (-1 * -1 &gt; 0)
```

```
## [1] TRUE
```

```r
length(c(1:10)) == length(seq(from = 1, to = 10, by = 2))
```

```
## [1] FALSE
```

--

- **Indexaci√≥n**


```r
c("a", "a,b", "c")[3] # El tercer elemento
```

```
## [1] "c"
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Breve resumen

- **¬øQu√© es un data frame?**

Es una estructura de datos de dos dimensiones (rectangular) que puede contener datos de diferentes tipos, por lo tanto, es heterog√©nea. Esta estructura de datos es la m√°s usada para realizar an√°lisis de datos, y es la estructura con la cual trabajaremos en esta secci√≥n.

--

- **Operador $**

Se utiliza para vincular una variable con un objeto.

--

- **Funci√≥n table()**

Se utiliza para tabular un resultado.

--


```r
x &lt;- data.frame(nombres = c("Ignacio", "Klaus", "Juan", "Ignacio"))
# Tabulaci√≥n
table(x$nombres)
```

```
## 
## Ignacio    Juan   Klaus 
##       2       1       1
```

---

background-image: url("imagenes/import.jpg")
background-size: cover
class: center, bottom, inverse

# Importaci√≥n de datos

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Importaci√≥n de datos

&lt;b&gt;R&lt;/b&gt; tiene distintos paquetes para importar datos, diferenciando la extensi√≥n de los archivos.

--

- Para importar archivos delimitados (.csv, .txt, .tab), existe el paquete `readr`. Dentro de las funciones de ese paquete, la funci√≥n `read_csv()` permite la importaci√≥n de archivos con la extensi√≥n "**.csv**".


```r
# Para usar el paquete primero es necesario cargarlo
library(readr)
# Al usar la funci√≥n, asignamos el archivo a un valor
base_csv  &lt;-  read_csv(file = "ejemplo.csv")
```

--

- El paquete `readxl` nos permite importar archivos de Excel. Una de sus funciones es `read_excel()`.


```r
# Para usar el paquete primero es necesario cargarlo
library(readxl)
# Al usar la funci√≥n, asignamos el archivo a un valor
base_excel  &lt;-  read_excel(file = "ejemplo_excel.xlsx",
                           sheet="Hoja1")
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Importaci√≥n de datos

Tanto las funciones de `readr` como `readxl` tienen argumentos que permiten setear distintas opciones para la importaci√≥n.

--

&lt;br&gt;

.pull-left[
### `readr`

- Cambiar nombres de columnas

- Saltarse l√≠neas al momento de importar

- Recodificar valores perdidos
]

.pull-right[
### `readxl`

- Leer un rango espec√≠fico de la hoja de c√°lculo

- Cambiar nombres de columnas

- Saltarse l√≠neas al momento de importar

- Recodificar valores perdidos
]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Importaci√≥n de datos

.pull-left[
Para importar archivos guardados desde Stata o SPSS existe el paquete `haven`.

Al igual que los paquetes `readxl` o `readr` tiene funciones bastante expl√≠citas respecto de lo que hacen:

- **SPSS**: `read_sav()` permite importar archivos ".sav".

- **Stata**: `read_dta()` permite importar archivos ".dta".
]

.pull-right[
.center[
![](imagenes/logo_haven.png)
]
]


```r
# Cargar librer√≠a
library(haven)
esi &lt;-  read_dta("data/esi_2018_personas.dta")
```

--

La funci√≥n `read_dta()` permite cargar bases de datos desde sitios web.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Importaci√≥n de datos

Los archivos de R tienen la extensi√≥n `.RData`.

--

Para importar estas bases se usa el comando `load()`.

--

La importaci√≥n de un archivo en R no requiere una asignaci√≥n de valor.

--

Estos archivos puede incluir m√°s de un objeto.

--


```r
load(file = "data/Censo_area.RData")
```

--

Comencemos con nuestro ejercicio...

--

Importemos el archivo de Excel "**`Censo_area.xlsx`**"... 

--

**¬øQu√© funci√≥n debemos utilizar?**

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Importaci√≥n de datos

Debemos utilizar la funci√≥n `read_excel` de la librer√≠a `readxl`.

--

Esta funci√≥n requiere indicar el nombre de la base a importar, as√≠ como la ruta en donde se encuentra guardada.

--

**IMPORTANTE**: al escribir la ruta, se debe utilizar el s√≠mbolo "**`/`**".

--


```r
library(readxl)
base &lt;- read_excel(path = "data/Censo_area.xlsx")
```

--

¬øC√≥mo se puede revisar la estructura de la base de datos?

--


```r
str(base)
```

```
## tibble [6,464 x 5] (S3: tbl_df/tbl/data.frame)
##  $ C√ìDIGO_REGI√ìN: chr [1:6464] "15" "15" "15" "15" ...
##  $ EDAD         : chr [1:6464] "0" "1" "2" "3" ...
##  $ N            : num [1:6464] 135 120 123 129 133 133 151 147 146 132 ...
##  $ AREA         : num [1:6464] 2 2 2 2 2 2 2 2 2 2 ...
##  $ SEXO         : num [1:6464] 2 2 2 2 2 2 2 2 2 2 ...
```

--

Ahora que importamos la base de datos, trabajaremos con la manipulaci√≥n de los data frames.

---

background-image: url("imagenes/transformer.gif")
background-size: cover
class: center, bottom, inverse

# Transformaci√≥n de datos

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## El paquete `dplyr`


.pull-left[

Para la manipulaci√≥n de los data frames existe un paquete llamado **`dplyr`**.

Este paquete fue desarrollado por Hadley Wickham de RStudio.

Es una versi√≥n optimizada de un paquete anterior llamado `plyr`.
 
El paquete `dplyr` proporciona una "gram√°tica" (particularmente verbos) para la manipulaci√≥n y operaciones con data frames.
 
Los paquetes `dplyr`, `readr`, `readxl` y `haven` forman parte del universo de [`tidyverse`](https://www.tidyverse.org).

]

.pull-right[
.center[
![](https://d33wubrfki0l68.cloudfront.net/071952491ec4a6a532a3f70ecfa2507af4d341f9/c167c/images/hex-dplyr.png)
]
]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

Durante esta sesi√≥n veremos siete funciones del paquete **`dplyr`** que se utilizan para la manipulaci√≥n de data frames.

--

- **select**: selecciona y devuelve un conjunto de columnas.

--

- **filter**: selecciona y devuelve un conjunto de filas seg√∫n una o varias condiciones l√≥gicas.

--

- **arrange**: reordena filas de un data frame.

--

- **rename**: renombra variables en un data frame.

--

- **mutate**: a√±ade nuevas variables o transforma variables existentes.

--

- **group_by**: agrupa filas de un data frame.

--

- **summarise**: genera res√∫menes de datos.

--

Estas funciones ser√°n algunas de nuestras mejores compa√±eras y siempre nos acompa√±ar√°n en nuestro camino de programaci√≥n.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

Todas estas funciones tienen en com√∫n una serie de argumentos:

--

- El primer argumento es el data frame a manipular.

--

- Los otros argumentos describen qu√© hacer con el data frame especificado en el primer argumento.

--

-	El valor de retorno de la funci√≥n es un nuevo data frame.

--

Como veremos en esta sesi√≥n, una de las principales ventajas de estas funciones es que podemos referirnos a las columnas en el data frame directamente sin utilizar el operador ‚Äú**`$`**‚Äù, es decir, solo con el nombre de la variable.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `select()`

La primera funci√≥n que veremos es la funci√≥n `select()`.

--

Esta funci√≥n es utilizada para seleccionar columnas dentro de un data frame.

--

El resultado de esta funci√≥n corresponde a un data frame que solo incluye las variables seleccionadas.

--

.center[
&lt;img src="imagenes/select.png" width="300" /&gt;
]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `select()`

El orden definido en la selecci√≥n de variables, es el orden que tendr√°n las columnas en el resultado.

--

La selecci√≥n puede ser realizada...

--

.pull-left[
...seg√∫n nombre de la variable.


```r
library(dplyr)
head(select(base, EDAD, N))
```

```
## # A tibble: 6 x 2
##   EDAD      N
##   &lt;chr&gt; &lt;dbl&gt;
## 1 0       135
## 2 1       120
## 3 2       123
## 4 3       129
## 5 4       133
## 6 5       133
```
]

--

.pull-right[
...seg√∫n √≠ndice de la variable.


```r
library(dplyr)
head(select(base, 3, 2))
```

```
## # A tibble: 6 x 2
##       N EDAD 
##   &lt;dbl&gt; &lt;chr&gt;
## 1   135 0    
## 2   120 1    
## 3   123 2    
## 4   129 3    
## 5   133 4    
## 6   133 5
```
]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `select()`

Otra forma de seleccionar consiste en definir qu√© columnas no se seleccionar√°n. Para esto es necesario incluir el signo menos ("**`-`**") antes de las columnas a seleccionar

--

Esta manera de seleccionar se puede entender como "la eliminaci√≥n de columnas".

--

Realicemos un ejercicio...

--

En un objeto llamado `ejemplo`, seleccionar solo las primeras 3 columnas del objeto `base`.

--


```r
head(select(base, -4, -5), n = 4)
```

```
## # A tibble: 4 x 3
##   C√ìDIGO_REGI√ìN EDAD      N
##   &lt;chr&gt;         &lt;chr&gt; &lt;dbl&gt;
## 1 15            0       135
## 2 15            1       120
## 3 15            2       123
## 4 15            3       129
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `select()`

Realicemos algunos ejercicios...

--

Creemos un data frame:


```r
df &lt;- data.frame(x1 = c(1:3),
                 x2 = c(1,7,2),
                 y3 = c("a","b","c"),
                 x4 = c(5,-1,8),
                 x5 = c("perro","gato","conejo"),
                 y1 = c(1, "perro", "gato"))
```

--

Ahora que creamos el data frame, realicemos algunas selecciones:

--

- Seleccionemos todas las columnas excepto x4 y x5.

--

- Reordenemos las columnas en el siguiente orden: x1, y1, x5, y3, x2 y x4.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `select()`

Cuando trabajamos con bases de datos, a veces nos encontramos con variables cuyo nombre sigue cierto patr√≥n, por ejemplo:

- La primera letra es la misma (a1, a2, a3).

- La variable posee un mismo sufijo (a1_otro, a2_otro, a3_otro)

--

Existen funciones auxiliares a `select()`, las cuales permiten trabajar con ciertos patrones.

--

Una que utilizaremos reiteradas veces dentro de las siguientes secciones es `starts_with()`. 
--
Esta funci√≥n auxiliar se utiliza para identificar las variables que comienzan con un cierto prefijo.

--

Por ejemplo, seleccionemos las variables que comienzan con la letra "**x**".

--


```r
head(select(df, starts_with("x")))
```

```
##   x1 x2 x4     x5
## 1  1  1  5  perro
## 2  2  7 -1   gato
## 3  3  2  8 conejo
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `filter()`

--

Esta funci√≥n se utiliza para filtrar un data frame seg√∫n alguna condici√≥n a definir.

--

As√≠ como la funci√≥n `select` es utilizada para seleccionar columnas de un data frame, la funci√≥n `filter` puede ser entendida como la selecci√≥n de filas de un data frame.

--

.center[
&lt;img src="imagenes/filter.png" width="400" /&gt;
]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `filter()`

¬øEs posible filtrar en base a m√°s de una condici√≥n?

--

**SI**, es posible utilizando operadores l√≥gicos.

--

Por ejemplo, si queremos filtrar nuestra base, y seleccionar a las mujeres de la regi√≥n 6 y de edad 35, debemos hacer lo siguiente...

--


```r
library(dplyr)
filter(base, SEXO == 2 &amp; C√ìDIGO_REGI√ìN == 6 &amp; EDAD == 35)
```

```
## # A tibble: 2 x 5
##   C√ìDIGO_REGI√ìN EDAD      N  AREA  SEXO
##   &lt;chr&gt;         &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 6             35     1431     2     2
## 2 6             35     5245     1     2
```

--

**Ejercicio**: filtrar el data frame "df", seg√∫n los criterios: x1 &gt; 2 y x5 es distinto de "perro".

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `arrange()`

--

Como se vio en la sesi√≥n anterior, esta funci√≥n se utiliza para reordenar las filas de un data frame:

--

- El orden se puede realizar seg√∫n una o m√°s columnas.

--

- El reordenamiento se realiza seg√∫n el orden de las columnas seleccionadas.

--

- Por defecto, el orden es ascendente.

--

- Para ordenar de manera descendente se debe utilizar la funci√≥n auxiliar `desc()`.


```r
head(arrange(base,desc(SEXO),N),n=3)
```

```
## # A tibble: 3 x 5
##   C√ìDIGO_REGI√ìN EDAD      N  AREA  SEXO
##   &lt;chr&gt;         &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 15            96        0     2     2
## 2 2             95        0     2     2
## 3 2             96        0     2     2
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `rename()`

--

Si queremos **`renombrar`** una variable (columna) de un data frame, existen m√∫ltiples formas y varias muy complejas.

--

La funci√≥n `rename` permite modificar el nombre de una variable de una manera sencilla, sin editar el resto de variables.

--

Para obtener el nombre de las variables en un data frame se utiliza la funci√≥n `names()`.

--


```r
# Funci√≥n para obtener nombres de las columnas
names(df)
```

```
## [1] "x1" "x2" "y3" "x4" "x5" "y1"
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `rename()`

La funci√≥n **`rename`** permite renombrar una variable o m√°s de un variable cada vez.

--


```r
df &lt;- rename(df, var1 = x1, var5 = x5)
head(df)
```

```
##   var1 x2 y3 x4   var5    y1
## 1    1  1  a  5  perro     1
## 2    2  7  b -1   gato perro
## 3    3  2  c  8 conejo  gato
```

--

La funci√≥n **`rename_all`** permite renombrar todas las variables dentro de un data frame, y combinado con la funci√≥n `tolower` permite pasar a min√∫scula todos los nombres.


```r
base &lt;- rename_all(base, tolower)
names(base)
```

```
## [1] "c√≥digo_regi√≥n" "edad"          "n"             "area"         
## [5] "sexo"
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `mutate()`

La funci√≥n **`mutate()`** tiene la finalidad de realizar transformaciones sobre los valores de un data frame.

--

Algunas de las transformaciones posibles son:

--

- Cambiar el formato de una variable.

--


```r
# Cambiar el formato de una variable
class(df$x4)
```

```
## [1] "numeric"
```

```r
df &lt;- mutate(df, x4 = as.character(x4))
class(df$x4)
```

```
## [1] "character"
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `mutate()`

- Modificar el valor de alguna variable.

En este caso se requiere la utilizaci√≥n de una funci√≥n auxiliar llamada `ifelse()`. Esta funci√≥n trabaja con los siguientes argumentos: *test*, *yes* y *no*.

--


```r
# Modificar la edad "100 o m√°s" por 100
base &lt;- mutate(base,
               edad = ifelse(test = edad == "100 o m√°s",
                             yes = "100",
                             no = edad))
table(base$edad == "100")
```

```
## 
## FALSE  TRUE 
##  6400    64
```


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `mutate()`

- Permite utilizar variables del data frame para transformar otras.

--

Un mini ejercicio:
--
 utilizando el objeto **`base`**, generar una variable llamada `tramos_edad`, la cual agrupe a las personas en 3 tramos (0-30, 31-60, 61-100).
 
--


```r
# Cambiar el formato de una variable
base &lt;- mutate(base,
               edad = as.numeric(edad))
base &lt;- mutate(base,
               tramos_edad = ifelse((edad %in% 0:30),
                                    1,
                                    ifelse((edad %in% 31:60),
                                           2,
                                           3)))
table(base$tramos_edad, useNA = "always")
```

```
## 
##    1    2    3 &lt;NA&gt; 
## 1984 1920 2560    0
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

## Funci√≥n `mutate()`

- Permite modificar el valor de m√°s de una variable. La modificaci√≥n se realiza de izquierda a derecha.

--

- Permite crear una variable que no existe

--

A continuaci√≥n un peque√±o ejercicio...

--

Utilizando el data frame `df`, generar una variable `x1` con los mismos valores de `var1`. Luego, generar una variable `x6` cuyos valores sean igual a `x1 + x2`. Asignar el resultado de la funci√≥n al data frame `df`.

--


```r
df &lt;- mutate(df,
            x1 = var1,
            x6 = x1 + x2)
head(df)
```

```
##   var1 x2 y3 x4   var5    y1 x1 x6
## 1    1  1  a  5  perro     1  1  2
## 2    2  7  b -1   gato perro  2  9
## 3    3  2  c  8 conejo  gato  3  5
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

Hasta ahora hemos visto c√≥mo `renombrar` variables, c√≥mo `seleccionar` columnas, c√≥mo `filtrar` filas, c√≥mo `reordenar` las filas y c√≥mo `crear/transformar` variables en un data frame.

--

Realicemos un ejercicio aplicando lo aprendido:

- Utilizando el data frame `base`, renombrar la variable `c√≥digo_regi√≥n` y asignarle el nombre `region`. El resultado guardarlo en el objeto `resultado`.

Las siguientes transformaciones realizarlas sobre el objeto `resultado`.

- Reordenar las columnas de forma tal que la columna `n` corresponda a la √∫ltima columna del data frame.

- Cambiar el formato de las variables `region` y `edad`, y convertirlas en variables num√©ricas (usar `as.numeric()`).

- Filtrar el objetivo, y solo quedar con los registros que correspondan a mujeres (sexo == 2) con regi√≥n distinta a la 1 (region == 6).

- Reordenar las filas de acuerdo a: `region` y `edad`.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Transformaci√≥n de datos

El resultado es el siguiente:


```r
# Renombrar
resultado &lt;- rename(base, region = c√≥digo_regi√≥n)
# Seleccionar
resultado &lt;- select(resultado, c(1,2,4,5,3))
# Cambiar el formato
resultado &lt;- mutate(resultado, region = as.numeric(region),
                    edad = as.numeric(edad))
# Cambiar el formato
resultado &lt;- filter(resultado, (sexo == 2 &amp; region == 6))
# Reordenar filas
resultado &lt;- arrange(resultado, region, edad)
# Miremos el resultado
head(resultado, n = 3)
```

```
## # A tibble: 3 x 5
##   region  edad  area  sexo     n
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1      6     0     2     2  1264
## 2      6     0     1     2  4246
## 3      6     1     2     2  1367
```

--

¬øEs posible encadenar todas estas instrucciones?
--
 Si, utilizando el operador **`%&gt;%`** (llamado **pipe**)

---

background-image: url("imagenes/pipes.jpg")
background-size: cover
class: center, bottom, inverse

# &lt;b&gt;&lt;font color = "Black"&gt;Uso de pipes&lt;/font&gt;&lt;/b&gt;

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Uso de pipes

El operador **%&gt;%** nos permite tomar el resultado de una funci√≥n y mandarlo directamente a la siguiente funci√≥n, concatenando acciones.

--

Se puede leer como "luego" o "a continuaci√≥n".

--

Este operador nos ayudar√° enormemente a mejorar la legibilidad de un c√≥digo.

--

Utilizando pipes, el resultado del ejercicio anterior es posible escribirlo de la siguiente manera:


```r
library(dplyr)
resultado &lt;- base %&gt;% # data frame a manipular
  rename(region = c√≥digo_regi√≥n) %&gt;% # renombrar
  select(1,2,4,5,3) %&gt;% # seleccionar columnas
  mutate(region = as.numeric(region),
         edad = as.numeric(edad)) %&gt;% # cambiar formatos
  filter(sexo == 2 &amp; region == 6) %&gt;% # filtrar data frame
  arrange(region, edad) # ordenar filas
```

---

background-image: url("imagenes/group_by_ungroup.png")
background-size: 100% 100%
class: center, bottom, inverse

# &lt;font color = "blue"&gt;Agrupaci√≥n de unidades&lt;/font&gt;

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Resumen de informaci√≥n

Para la generaci√≥n de tablas de resumen de informaci√≥n se utilizan dos funciones: 

- `group_by()`
- `summarise()`

--

La funci√≥n `group_by()` permite agrupar a las observaciones seg√∫n una categor√≠a de una variable y aplicarles alguna funci√≥n.

--

Esto resulta muy √∫til pues muchos nuestros an√°lisis estad√≠sticos se aplican sobre grupos definidos por una variable o una combinaci√≥n de variables (sexo, regi√≥n, comuna, etc).
 
--

Gran parte del an√°lisis de datos que realizamos involucra la aplicaci√≥n de una estrategia que en ingl√©s se acu√±a como *split-apply-combine*.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Resumen de informaci√≥n

.center[
&lt;img src="imagenes/group.png" width="400" /&gt;
]

- Primero `group_by()` divide el *data frame*.

- Luego opera una funci√≥n con la data fragmentada.

- Finalmente `group_by()` vuelve a combinar los resultados.

--

¬øQu√© funciones podemos aplicar sobre la data fragmentada?

--

Todas las funciones que hemos visto durante esta sesi√≥n pueden ser combinadas con `group_by()`, pero una que funciona perfectamente es `summarise()`.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Resumen de informaci√≥n

La funci√≥n `summarise()` crea una o m√°s escalares resumiendo informaci√≥n de variables existentes en un data frame.

--

En combinaci√≥n con otras funciones, es una manera de tabular informaci√≥n.

--

Algunas funciones que se pueden operar dentro de `summarise()` son:

--

- Tendencia central: `mean()`, `median()`.

--

- Rango: `min()`, `max()`. `quantile()`.

--

- Posici√≥n: `first()`, `last()`.

--

- Conteo: `n()`, `n_distinct()`.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Resumen de informaci√≥n

Ahora que ya conocemos estas funciones: ¬øcu√°ntas hombres hay por tipo de √°rea y regi√≥n?

--

Para resolver a la pregunta, tomamos el objeto **resultado**, filtramos a los hombres, agrupamos por tipo de √°rea y regi√≥n, y obtenemos la suma de "n".

--


```r
base %&gt;%
  rename(region = c√≥digo_regi√≥n) %&gt;%
  filter(sexo == 1 &amp; region == 12) %&gt;%
  group_by(area, tramos_edad) %&gt;%
  summarise(total = sum(n)) %&gt;%
  ungroup()
```

```
## # A tibble: 6 x 3
##    area tramos_edad total
##   &lt;dbl&gt;       &lt;dbl&gt; &lt;dbl&gt;
## 1     1           1 33501
## 2     1           2 31558
## 3     1           3 11056
## 4     2           1  3553
## 5     2           2  4406
## 6     2           3  1175
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Resumen de informaci√≥n

Revisemos el ejercicio bonus de la tarea 1: ¬øcu√°l es el nombre m√°s usado en Chile en todos los tiempos?

--

Lo primero que tenemos que hacer es cargar la librer√≠a **guaguas**, luego asignar la base de guaguas a un objeto llamado guaguas, por √∫ltimo, debemos generar el cuadro resumen.

--


```r
library(guaguas)
guaguas &lt;- guaguas
guaguas %&gt;%
  group_by(nombre) %&gt;%
  summarise(total = sum(n)) %&gt;%
  arrange(desc(total)) %&gt;%
  slice(1) %&gt;%
  select(nombre)
```

```
## # A tibble: 1 x 1
##   nombre
##   &lt;chr&gt; 
## 1 Mar√≠a
```

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ejercicio para la üè†

--

Vamos a trabajar con una base real de la **Encuesta Nacional Urbana de Seguridad Ciudadana (ENUSC)**, que levanta el INE a√±o a a√±o. Utilizaremos la √∫ltima versi√≥n publicada (2019). 

--

Para la ENUSC, un **hogar victimizado** es aquel en el cual durante el √∫ltimo a√±o **alguno de sus miembros fue v√≠ctima de al menos uno de los siguientes delitos:** 

--

- robo con intimidaci√≥n (**A1_1_1**)
- robo por sorpresa (**B1_1_1**)
- robo con fuerza en la vivienda (**C1_1_1**)
- hurto (**D1_1_1**)
- lesiones (**E1_1_1**)
- robo de veh√≠culo (**G1_1_1**)
- robo desde veh√≠culo (**H1_1_1**)

--

Es decir, basta con tener un valor 1 (s√≠) en cualquiera de estas variables para que este hogar sea **victimizado**.

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ejercicio para la üè†

## Ahora s√≠ el ejercicio:

En primer lugar debes Descargar la base de datos 2019 desde el [sitio de la ENUSC en la p√°gina del INE](https://www.ine.cl/estadisticas/sociales/seguridad-publica-y-justicia/seguridad-ciudadana). Puedes descargarla en formato .csv o en .sav (SPSS).  Crea o escoge un fichero en tu computador y descomprimer el archivo ah√≠.

--

1- Utilizando las funciones de **importaci√≥n** aprendidas, carga la base de datos en tu entorno de trabajo de **R**.

--

2- ¬øCu√°ntas observaciones y cuantas variables tiene la base?

--

3- La base es un poco **grande** y los nombres de las variables **poco intuitivos** üòµ. Simplifiquemos la base:

--

    - filtrando solo a los informantes de la encuesta (Kish == 1).
    
    - seleccionando solo las variables que que usaremos (`enc_region` y   
    las variables de victimizaci√≥n indicadas en la l√°mina anterior)
    
    - y renombrando estas variables para hacerlas m√°s entendibles (sugerencia: region,
    intimidacion, sorpresa, fuerza_viv, hurto, lesiones, de_vehiculo, desde_vehiculo) 
    
---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ejercicio para la üè†

--
    
  Puedes hacer todo lo anterior en una sola instrucci√≥n usando `pipes` (`%&gt;%`). Te recomendamos guardarla en un objeto diferente, por ejemplo: `enusc_2`.
  
--

 4- ¬øCu√°ntas observaciones y cuantas variables tiene tu base ahora?

--

 5- Ahora, Genera una **variable dicot√≥mica con valores 0 y 1** que indique, a partir de las variables de delitos, si un hogar ha sido v√≠ctima de al menos un delito. Crearla dentro de la base de datos y ponerle como nombre `VA_DC_2`.

--

 6- Compara la victimizaci√≥n agregada que calculamos (`VA_DC_2`) con la que ya viene construida en la base original (`VA_DC`). ¬øSon iguales?

--

 7- Crear una tabla que muestre la victimizaci√≥n agregada para cada regi√≥n (**Sin usar factores de expansi√≥n**).


---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Ejercicio para la üè†

**hint 1** üëÄ:

Puedes usar `ifelse()`, a trav√©s de mutate, para generar variables dicot√≥micas.


```r
enusc_2 &lt;- enusc_2 %&gt;% 
  mutate(intimidacion = ifelse(intimidacion==1,1,0))
```

--

**hint 2** üïµ:

Existe una funci√≥n llamada `rowSums()`. que te podr√≠a servir para sumar un total fila sobre un set de variables.

--

**hint 3** ü•∏:

Los valores `NA` son muy contagiosos. Puedes evitar su influencia usando el argumento `na.rm = TRUE`.


.center[ü§îüß†]

---

background-image: url("imagenes/fondo2.PNG")
background-size: contain;
background-position: 100% 0%

# Referencias

Nada de esto ser√≠a posible sin:

- [`R fot Data Science, de Hadley Wickham`](https://r4ds.had.co.nz/)

- [`Advanced R, de Hadley Wickham`](http://adv-r.had.co.nz/Introduction.html)

- [`Data wrangling, exploration, and analysis with R, de Jenny Bryan`](https://stat545.com/index.html)

- [`Introduction to R, de Data Carpentry`](https://datacarpentry.org/R-genomics/01-intro-to-R.html#functions)

- [`Xaringan: Presentation Ninja, de Yihui Xie`](https://github.com/yihui/xaringan). Para generar esta presentaci√≥n con la planilla ninja ‚öî

R for Data Science tiene una traducci√≥n al espa√±ol realizada por la comunidad hispana de R:

- [`R para ciencia de datos, de Hadley Wickham`](https://es.r4ds.hadley.nz/)

---

class: center, middle

.linea-superior[]
.linea-inferior[]


&lt;img src="imagenes/logo_portada2.png" width="200" /&gt;

## Capacitaci√≥n en R y herramientas de productividad

## Proyecto Estrat√©gico Servicios Compartidos para la Producci√≥n Estad√≠stica

## Procesamiento de bases de datos

### Agosto 2020
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
